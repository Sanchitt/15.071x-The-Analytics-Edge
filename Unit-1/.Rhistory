y <- c(1.0, "s")
y <- c(1.9, "s")
y <- c(T, 2)
y <- c(1, t)
y
y <- c(1, T)
matrix(3,3)
matrix(nrow = 3,ncol = 3)
m = matrix(nrow = 3,ncol = 3)
dim(m)
n = matrix(1:10, 2, 2)
n
dim(n) <- (4,4)
dim(n) <- c(4,4)
dim(n) <- c(4,2)
dim(n) <- c(3,3)
dim(n) <- c(1,1)
n
dim(n) <- c(1,4)
n
x <- 1:10
y <- 1:10
cbind(x,y)
rbind(x,y)
lm
frames
f
f()
frame()
x <- data.frame(foo = 1:10, bar = c(T, F, T, T, F, T, F, F, F, T, T))
x <- data.frame(foo = 1:10, bar = c(T, T, T, F, T, F, F, F, T, T))
x
x.names
x.names()\
x.names()
x
attributes(x)
names(x)
row.names(x)
class(x)
matrix(x)
codeuse = url("http://codeuse.com")
codeuse
attributes(codeuse)
read(codeuse)
codeuse
codeuse
url
codeuse <- url("http://codeuse.com")
codeuse
readLines(codeuse, 10)
x <- readLines(codeuse)
head(x)
x
library(swirl)
rm(codeuse)
rm(*)
install.packages("swirl")
x <- 4
class(c)\
class(c)
class(x)
x <- c(4, TRUE)
class(x)
x <- c(1,3,5)
y <- c(3, 2, 10)
cbind(x,y)
x <- list(2, "a", "b", TRUE)
x[[2]]
class(x[[2]])
x <- 1:4
y <- 2
x+y
x <- c(17, 14, 4, 5, 13, 12, 10)
x[x > 10] <- 4
x
d
d <- read
read.csv
d <- read.csv("hw1_data.csv")
d
names(d)
head(d, 2)
nrows(d)
d
attributes(d)
data.frame(d)
count(d)
ncount
dim(d)
tail(d, 2)
d[47]
d[[47]]
d$4
d
data.frame(d)
p <- data.frame(d)
p[47]
matrix(p)
p
p[[0][1]]
p[c(0,1)]
p[c(0,1)][47]
NROW(p)
p[47]
p[47, "Ozone"]
NROW(p)
p[is_nan, "Ozone"]
p[is_nan(p), "Ozone"]
p(is_nan(p))
is_nan(p)
isnan
is_na
isnan
p[, "Ozone"]
q <- p[, "Ozone"]
q
!q
is.na(q)
is.na(q).length
NROW(is.na(q))
length(which(is.na(q)))
sum
sum(q)
q
q[is.na(q)] = q
q[is.na]
is.na(q)
which(is.na(q))
sum(!is.na(q))
sum(!is.na(q))/NROWS(!is.na(q))
sum(!is.na(q))/NROW(!is.na(q))
p
q <- p(1, "Ozone")
q <- p(1, "Ozone"]
q <- p[1, "Ozone"]
q
q <- p[, "Ozone"]
q
is.na(q)
which(is.na(q))
which(!is.na(q))
q
sum(q[which(!is.na(q))])
sum(q[which(!is.na(q))])/NROW(q)
sum(q[which(!is.na(q))])/NROW(q[which(!is.na(q))])
d
d
p
q <- p(, c(1,4))
q <- p[], c(1,4)]
q <- p[, c(1,4)]
q
q
q[[1] > 31]
q[>31]
q
q[,>31]
q[,]
q
q
q
q[1, Ozone]
q[1, "Ozone"]
q[, "Ozone"]
q[, "Ozone" > 31]
"Ozone" > 31
q
q[["Ozone"]]
o <- q[["Ozone"]]
o <- q[["Temp"]]
t <- q[["Temp"]]
cbind(o,t)
cbind(o > 31,t)
cbind(o[which(o > 31)],t)
q
p
p[["Ozone"]] > 31
o
o > 31
p
p[["Ozone"]] > 31
which(p[["Ozone"]] > 31)
p[["Ozone"]] > 31
p[["Temp"]] > 90
p[["Ozone"]] > 31 and p[["Temp"]] > 90
p[["Ozone"]] > 31 && p[["Temp"]] > 90
p[["Ozone"]] > 31 p[["Temp"]] > 90
True * True
T * T
T & T
p[["Ozone"]] > 31 & p[["Temp"]] > 90
which(p[["Ozone"]] > 31 & p[["Temp"]] > 90)
p
s <- p[["Solar.R"]]
s
a <- which(p[["Ozone"]] > 31 & p[["Temp"]] > 90)
s[[a]]
s[a]
sum(s[a])/NROW(a)
a
m <- p[["Month"]]
m
m == 6
which(m == 6)
t
b <- which(m == 6)
m[b]
t[b]
sum(t[b])/NROW(b)
m
which(m == 5)
c <- which(m == 5)
o
max(o[c])
o
o[c]
m
m == 5
which(m == 5)
o[which(m == 5)]
o <- p[["Ozone"]]
o
o[which(m == 5)]
max(o[which(m == 5)])
o[which(m == 5)]
o
is.na(o)
is.na(o[which(m == 5)])
!is.na(o[which(m == 5)])
which(!is.na(o[which(m == 5)]))
max(o[which(!is.na(o[which(m == 5)]))])
x <- c(4, "a", TRUE)
class(x)
x <- c(1,3, 5)
y <- c(3, 2, 10)
cbind(x, y)
class(cbind(x, y))
x <- list(2, "a", "b", TRUE)
class(x[[1]])
x[[1]]
x <- 1:4
y <- 2
x+y
x <- c(17, 14, 4, 5, 13, 12, 10)
x>10
x[x>10] = 4
x
x[x>10] <- 4
x <- c(17, 14, 4, 5, 13, 12, 10)
x[x>10] <- 4
x
library(swirl)
install.packages(swirl)
installed.packages
installed.packages()
install.packages("swirl")
library(swirl)
library("swirl")
install.packages("RCurl")
install.packages("RCurl")
library("swirl")
install.packages("swirl")
swirl()
library(swirl)
swirl()
install_from_swirl("R Programming")
swirl()
5+7
x <- 5+7
x
y <- x-3
y
c(1.1, 9, 3.14)
z <- c(1.1, 9, 3.14)
?c
z
c(z, 555, z)
z * 2 + 100
my_sqrt <- sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10,100)
z * 2 + 1000
my_div
setwd
wd
ls
ls()
a
dir
dir()
library(datasets)
data(iris)
?iris
iris
apply
?apply
?sapply
?tapply
iris
?split
split(iris, iris$Sepal.Length)
sapply(split(iris, iris$Sepal.Length), mean)
?sapply
?sapply
sapply(split(iris, iris$Sepal.Length), mean, simplify = TRUE)
s <- split(iris, iris$Sepal.Length)
s
head(iris)
s <- split(iris, iris$Species)
s
head(s)
lapply(s, function(x) { colMeans(x[, "Sepal.Length"])})
lapply(s, function(x) { colMeans(x[, c("Sepal.Length")])})
s$virginica
s$virginica[, "Species"]
head(s$virginica)
s$virginica[, "Sepal.Length"]
lapply(s, function(x) colMeans(x[,"Sepal.Length"]))
lapply(s, print)
lapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
lapply(s, function(x) colMeans(x))
s
s$virginica
s$virginica["Sepal.Length"]
mean(s$virginica["Sepal.Length"])
colMeans(s$virginica["Sepal.Length"])
colMeans(iris)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
data(mtcars)
head(mtcars)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
apply(mtcars, 2, mean)
fc <- split(mtcars$hp, mtcars$cyl)
fc
sapply(fc, mean)
res <- sapply(fc, mean)
res
res$4
res[4]
res
res[,4]
res[,1]
dim(res)
typeof(res)
res["4"]
res["4"] - res["8"]
debug(ls)
ls()
q
exit
exitq()
ls()
n
n
n
n
n
n
n
q
q
q()
ls()
inv
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(invers) inv <<- invers
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(x)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinv(inv)
inv
}
x <- makeCacheMatix(matrix(1:4, c(2,2)))
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(invers) inv <<- invers
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(x)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinv(inv)
inv
}
x <- makeCacheMatix(matrix(1:4, c(2,2)))
x <- makeCacheMatrix(matrix(1:4, c(2,2)))
x$get()
x$getinv()
cacheSolve(x)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(invers) inv <<- invers
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinv(inv)
inv
}
x <- makeCacheMatrix(matrix(1:4, c(2,2)))
cacheSolve(x)
cacheSolve(x)
cacheSolve(x)
x <- makeCacheMatrix(matrix(1:4, c(2,2)))
cacheSolve(x)
cacheSolve(x)
str(gl)
summary(gl)
set.seed(20)
x <- rnorm(100)
e <- rnorm(100, 0, 2)
y < 0.5 + 2 * x + e
y <- 0.5 + 2 * x + e
plot(x,y)
x <- rbinom(100, 1, 0.5)
y <- 0.5 + 2 * x + e
plot(x,y)
set.seed(1)
x <- rnorm(100)
log.mu <- 0.5 + 0.3 * x
y <- rpois(100, exp(log.mu))
plot(x,y)
letters
set.seed(1)
sample(1:10, 4)
sample(letters, 5)
sample(1:10) #permutation
sample(1:10, replace = TRUE) # with replacement
library(swirl)
rm(list=ls())
library(swirl)
swirl()
getwd()
ls()
rm(list=ls())
rm(list=ls())
exit()
q
q()
setwd("~/Development/learning/edx/15.071x-The-Analytics-Edge/Unit-1")
?summaary
?summary
WHO = read.csv("WHO.csv")
summary(WHO)
WHO_India = subset(WHO, Country == "India")
summary(WHO_India)
str(WHO_India)
mean(WHO$Over60)
which.min(WHO$Over60)
who = WHO
who$Country[183]
which.max(who$LiteracyRate)
who$Country[44]
tapply(who$ChildMortality, who$Region, mean)
min(tapply(who$ChildMortality, who$Region, mean))
